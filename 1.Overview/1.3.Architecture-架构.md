# Apache Shiro架构

Apache Shiro的设计目标是让应用程序的安全开发更加直观而易于实现。Shiro的核心模型设计参考了大多数人对应用程序安全的思考模式--如何对人（或某事）在与程序交互的环境中进行安全控制。

程序设计通常都以用户故事为基础。也就是说，设计用户界面或服务API都是基于用户如何与软件交互之上的。例如，有这样一种情况，“如果用户已在应用里登录了，就会向他们显示一个按钮，他们可以点击查看其帐户信息。如果他们没有登录，就会显示一个注册按钮。”

这个陈述例子指出应用程序在很大程度上是为了满足用户需求。即使“用户”是另一个系统，而不是一个人，仍然可以写代码来对当前与您的系统交互的谁（或者什么）的相关操作进行回应。

Shiro在它的设计里体现了这些概念。为了与软件开发者的早已熟悉的概念相配合，Apache Shiro在几乎所有程序中都保持直观和易于使用。

## 高层抽象

在概念层次上，Shiro架构有3个主要核心概念：`Subject`、`SecurityManager`和`Realms`。下图显示了这些组件是如何交互的，将在下面依次对其进行描述：

![shiro high-leve overview](../assets/images/ShiroBasicArchitecture.png)

* **Subject**：正如在上一篇[入门教程](./1.2.Tutorial-入门教程.md)里提到的，`Subject`本质上指当前正在执行的用户的安全“视图”。而单词“User”通常意味着一个人，而`Subject`可以指一个人，但还可以指第三方服务、daemon进程、cron作业、或其他--简单来说，就是指正在和软件进行交互的事物。`Subject`实例都和（也需要）一个`SecurityManager`绑定。当和一个`Subject`进行交互，这些交互动作被转换成`SecurityManager`下`Subject`特定的交互动作。

* **SecurityManager**：`SecurityManager`是Shiro架构里的核心，它本质上是一把“保护伞”用来协调其内部的安全组件。一旦应用程序配置好了`SecurityManager`和它的内部对象，通常将它保存下来，开发者会集中在`Subject`的API使用上。稍后将再详细讨论`SecurityManager`的细节，不过需要好好记住，当您在使用`Subject`时，真正的幕后功臣是`SecurityManager`，它在幕后做了所有`Subject`的安全操作。上面的图示已反映出这点了。

* **Realms**：`Realms`在Shiro和您的应用程序的安全数据之前扮演“桥梁”或“连接器”角色。当实际和安全相关的数据（如用户帐户）进行交互，以用来执行认证（登录）和授权（访问控制）时，Shiro从应用程序配置的一个或多个`Realms`里查找数据。`Realms`本质上是一个特定于安全领域的[DAO](https://en.wikipedia.org/wiki/Data_access_object)：它封装了数据源连接的细节，获取Shiro所需的相关数据。在配置Shiro时，必须至少指定一个用于认证或授权的`Realms`。`SecurityManager`可以配置多个`Realms`，但至少要有一个。Shiro提供了很多开箱即用的`Realms`来连接常用的安全数据源，如LDAP、关系数据库（JDBC）、文本配置文件如INI和properties文件等等。如果默认实现的`Realms`不满足您的需求，您还可以自定义`Realms`实现来连接具体的数据源。与其他内部组件一样，Shiro的`SecurityManager`管理如何使用 `Realms`获取`Subject`实例所代表的安全和身份数据。

## 详细架构

下图显示了Shiro的核心架构，并进宪简要说明：

![shiro core architectural concepts](../assets/images/ShiroArchitecture.png)

* **Subject**（[org.apache.shiro.subject.Subject](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html)）：一个当前正在与系统交互的实体（用户、第三方服务、cron作业等）的安全“视图”。

* **SecurityManager**（[org.apache.shiro.mgt.SecurityManager](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/mgt/SecurityManager.html)）：如上面所述，`SecurityManager`是Shiro架构的核心。它本质上是一把“保护伞”用来协调其内部组件，使之平稳地一起工作。它也管理着Shiro中每一个程序用户的视图，因此它知道如何对每个用户执行安全操作。

* **Authenticator**（[org.apache.shiro.authc.Authenticator](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html)）：`Authenticator`是用来执行和响应用户认证（登录）的组件。当用户尝试登录时，`Authenticator`就开始执行。`Authenticator`知道如何协调一个或多个存储了相关用户/帐户信息的`Realms`。从`Realms`里获取到的数据将用来验证用户的身份，以保证用户是合法的。

  * **Authentication Strategy**（[org.apache.shiro.authc.pam.AuthenticationStrategy](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AuthenticationStrategy.html)）：若配置了多个`Realm`，`AuthenticationStrategy`将会协调Realms来确定身份验证的成功或失败的条件（例如，如果一个realm成功，但其他realm都失败了，则表示成功？还是说所有realm都成功才算是成功？还是说第一个realm成功就可以？）。

* **Authorizer**（[org.apache.shiro.authz.Authorizer](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/Authorizer.html)）：

* **SessionManager**（[org.apache.shiro.session.mgt.SessionManager](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/SessionManager.html)）：

  * **SessionDAO**（[org.apache.shiro.session.mgt.eis.SessionDAO](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/eis/SessionDAO.html)）：

* **CacheManager**（[org.apache.shiro.cache.CacheManager](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/cache/CacheManager.html)）：

* **Cryptography**（[org.apache.shiro.crypto.*](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/crypto/package-summary.html)）：

* **Realms**（[org.apache.shiro.realm.Realm](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html)）：

## SecurityManager

## 设计
