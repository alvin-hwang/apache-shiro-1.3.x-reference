# Apache Shiro配置

Shiro设计成可用于任何环境，小到简单的命令行应用程序，大到复杂的企业集群应用程序。由于环境的多样性，可以使用多种配置机制来对Shiro进行配置。本章节仅仅讲述Shiro核心支持的配置机制。

> :heavy_check_mark: 诸多配置项

> Shiro的`SecurityManager`实现类和所有支持组件都是与JavaBean兼容的。这就允许Shiro可以使用任务的配置格式进行配置，如XML（Spring、JBoss、Guice等）、[YAML](http://www.yaml.org/)、JSON、Groovy Builder标识语言等等。

## 程序化配置

创建和使用`SecurityManager`最简单的方法就是实例化`org.apache.shiro.mgt.DefaultSecurityManager`类。例如：

```Java
Realm realm = //instantiate or acquire a Realm instance.  We'll discuss Realms later.
SecurityManager securityManager = new DefaultSecurityManager(realm);

//Make the SecurityManager instance available to the entire application via static memory:
SecurityUtils.setSecurityManager(securityManager);
```

惊奇吧，仅仅3行代码，就创建了一个功能齐全的Shiro环境了。就是这么简单！

### SecurityManager内部对象

正如在[架构](./1.3.Architecture-架构.md)章节里描述的，Shiro的`SecurityManager`的实现实质上是内嵌了很多模块化的安全组件对象的。因为他们是JavaBean兼容的，您可以通过内嵌组件的`getter`和`setter`方法来定制`SecurityManager`。

例如，若想使用自定义的`SessionDAO`来定制[会话管理](https://shiro.apache.org/session-management.html)，可以使用内嵌在`SecurityManager`的`setSessionDAO`方法来设置`SessionDAO`：

```Java
...

DefaultSecurityManager securityManager = new DefaultSecurityManager(realm);

SessionDAO sessionDAO = new CustomSessionDAO();

((DefaultSessionManager)securityManager.getSessionManager()).setSessionDAO(sessionDAO);
...
```

直接使用方法调用，可以配置`SecurityManager`里内置的所有对象。

但是，尽管程序化配置很简单，在实际的项目里它却不是理想的配置机制。程序化配置不适合的几个原因：

* 您必须知道实现类的具体实现细节。然而更好的做法是您不用关心具体的实现细节，也不用知道从哪里得到它们。

* 由于Java的类型安全特性，您必须对通过`get*`获取的对象进行强类型转换。那么多的强类型转换是超级恶心、累赘并且跟具体的实现类紧耦合。

* `SecurityUtils.setSecurityManager`方法会将`SecurityManager`实例化对象作为JVM静态单例，在大多数应用程序中没什么问题，但如果有多个使用Shiro的程序在同一个JVM中运行时，各自程序有自己独立的实例会更好些，而不是共同引用一个静态单例。

* 每次的配置更改，您都要重新编译您的应用程序。

尽管有这些不足，直接程序化配置在内存受限的环境里还是很有用的，如智能手机应用程序中就很有用。若您的应用程序不是在内存受限的环境中运行的，您会发现基于文件的配置机制可用性和可读性都更强。

## INI配置机制
